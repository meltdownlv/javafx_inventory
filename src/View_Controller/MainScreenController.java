package View_Controller;

import static Model.Inventory.lookupPart;
import static View_Controller.MyUtils.confirmPopup;
import static View_Controller.MyUtils.invalidPopup;

import Model.Inventory;
import Model.Part;
import Model.Product;
import java.io.IOException;
import java.net.URL;
import java.util.ResourceBundle;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.TextField;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.stage.Stage;

/**
 * The MainScreenController class controls the logic for the Main Screen
 * of the inventory application.
 * TODO Write Javadoc comments for class header and all @FXML fields
 * @author Sakae Watanabe
 */
public class MainScreenController implements Initializable {

  @FXML
  private TextField mainPartSearchText;

  @FXML
  private Button mainPartSearchButton;

  @FXML
  private TableView<Part> mainPartTableView;

  @FXML
  private TableColumn<Part, Integer> mainPartIDColumn;

  @FXML
  private TableColumn<Part, String> mainPartNameColumn;

  @FXML
  private TableColumn<Part, Integer> mainPartInvColumn;

  @FXML
  private TableColumn<Part, Double> mainPartPriceColumn;

  @FXML
  private Button mainAddPartButton;

  @FXML
  private Button mainModPartButton;

  @FXML
  private Button mainDeletePartButton;

  @FXML
  private TextField mainProductSearchText;

  @FXML
  private Button mainProductSearchButton;

  @FXML
  private TableView<Product> mainProductTableView;

  @FXML
  private TableColumn<Product, Integer> mainProductIDColumn;

  @FXML
  private TableColumn<Product, String> mainProductNameColumn;

  @FXML
  private TableColumn<Product, Integer> mainProductInvColumn;

  @FXML
  private TableColumn<Product, Double> mainProductPriceColumn;

  @FXML
  private Button mainAddProductButton;

  @FXML
  private Button mainModProductButton;

  @FXML
  private Button mainDeleteProductButton;

  @FXML
  private Button mainExitButton;

  /**
   * The Initialize method sets up items for both Part and Product
   * table views.
   * TODO: update javadoc for Main Screen initialize method.
   */
  @Override
  public void initialize(URL location, ResourceBundle resources) {
    // Setup parts table and load full list from Inventory.
    mainPartIDColumn.setCellValueFactory(new PropertyValueFactory<>("id"));
    mainPartNameColumn.setCellValueFactory(new PropertyValueFactory<>("name"));
    mainPartInvColumn.setCellValueFactory(new PropertyValueFactory<>("stock"));
    mainPartPriceColumn.setCellValueFactory(new PropertyValueFactory<>("price"));
    mainPartTableView.setItems(Inventory.getAllParts());

    // Setup products table and load full list from Inventory.
    mainProductIDColumn.setCellValueFactory(new PropertyValueFactory<>("id"));
    mainProductNameColumn.setCellValueFactory(new PropertyValueFactory<>("name"));
    mainProductInvColumn.setCellValueFactory(new PropertyValueFactory<>("stock"));
    mainProductPriceColumn.setCellValueFactory(new PropertyValueFactory<>("price"));
    mainProductTableView.setItems(Inventory.getAllProducts());

  }

  //===========================================================================
  // Part Table View Handlers
  //===========================================================================

  /**
   * The mainSearchPartHandler method responds to user input in the searchPart field
   * to either lookup a list of parts matching the given ID or part name. If no
   * results matched a popup is generated letting the user know that no results were found
   * and the original list is restored. Search text that is empty or all whitespace characters
   * will also restore the original list.
   *
   * @param event Event generated by user pushing searchPart button OR pressing
   *              Enter key after query has been typed.
   */
  @FXML
  private void mainSearchPartHandler(ActionEvent event) {
    String searchPart = mainPartSearchText.getText().trim();
    ObservableList<Part> searchPartResults = FXCollections.observableArrayList();
    try {
        int id = Integer.parseInt(searchPart);
        Part foundPart = Inventory.lookupPart(id);
        if (foundPart != null){
          searchPartResults.add(foundPart);
        }
    } catch (NumberFormatException e) {
        searchPartResults.addAll(Inventory.lookupPart(searchPart));
    }
    if (searchPartResults.isEmpty()) {
      mainPartSearchText.clear();
      invalidPopup("No Results", "No results were found matching input.");
      mainPartTableView.setItems(Inventory.getAllParts());
    } else {
      if (searchPart.equals("")) {
        mainPartSearchText.clear();
      }
      mainPartTableView.setItems(searchPartResults);
    }
  }

  /**
   * The addPartButtonPushed method handles changing the scene when the addPartButton
   * is pushed. A call is made to the AddModifyPartController initAddPart method to prepare
   * label for the scene.
   *
   * @param event Event captured when user pushes the addPartButton.
   */
  @FXML
  private void addPartButtonPushed(ActionEvent event) throws IOException {
    FXMLLoader loader = new FXMLLoader();
    loader.setLocation(getClass().getResource("/View_Controller/AddModifyPart.fxml"));
    Parent addPartParent = loader.load();
    Scene addPartScene = new Scene(addPartParent);

    AddModifyPartController controller = loader.getController();
    controller.initAddPart();

    Stage addPartWindow = (Stage) ((Node)event.getSource()).getScene().getWindow();
    addPartWindow.setScene(addPartScene);
    addPartWindow.show();
  }

  /**
   * The modPartButtonPushed method handles changing the scene when the modPartButton
   * is pushed. A call is made to the AddModifyPartController initModPart method to prepare
   * label and text fields for the modify part scene. Popup dialog is generated if user has
   * no item selected.
   *
   * @param event Event captured when user pushes the modPartButton.
   */
  @FXML
  private void modPartButtonPushed(ActionEvent event) throws IOException {
    Part selectedPart = mainPartTableView.getSelectionModel().getSelectedItem();
    int partIndex = Inventory.getAllParts().indexOf(selectedPart);

    if (selectedPart != null) {
      FXMLLoader loader = new FXMLLoader();
      loader.setLocation(getClass().getResource("/View_Controller/AddModifyPart.fxml"));
      Parent modPartParent = loader.load();
      Scene modPartScene = new Scene(modPartParent);

      AddModifyPartController controller = loader.getController();
      controller.initModPart(selectedPart, partIndex);

      Stage addPartWindow = (Stage) ((Node) event.getSource()).getScene().getWindow();
      addPartWindow.setScene(modPartScene);
      addPartWindow.show();
    } else {
      invalidPopup("No Part Selected", "Please select a part to modify.");
    }
  }

  /**
   * The deletePartButtonPushed method will delete the selected part from the mainPartTableView
   * after user confirms the action. Popup dialog is generated if user has no item selected.
   *
   * @param event Event captured when user pushes the deletePartButton.
   */
  @FXML
  private void deletePartButtonPushed(ActionEvent event) {
    Part selectedPart = mainPartTableView.getSelectionModel().getSelectedItem();
    if (selectedPart != null && (confirmPopup(event, "Are You Sure?",
        "Part will be permanently deleted from Inventory."))) {
          Inventory.deletePart(selectedPart);
    } else {
      invalidPopup("No Part Selected", "Please select a part to delete.");
    }
  }

  //===========================================================================
  // Product Table View Handlers
  //===========================================================================

  /**
   * The mainSearchProductHandler method responds to user input in the searchProduct
   * field to either lookup a list of matching products by given ID or part name. If
   * no results matched a popup is generated letting user know and restoring the table
   * to the original list. Search text that is empty or all whitespace characters
   * will also restore the original list.
   *
   * @param event Event generated by user pushing searchProduct button OR pressing
   *              Enter key after query has been typed.
   */
  @FXML
  private void mainSearchProductHandler(ActionEvent event) {
    String searchProduct = mainProductSearchText.getText().trim();
    ObservableList<Product> searchProductResults = FXCollections.observableArrayList();

    try {
      int id = Integer.parseInt(searchProduct);
      Product foundProduct = Inventory.lookupProduct(id);
      if (foundProduct != null) {
        searchProductResults.add(foundProduct);
      }
    } catch (NumberFormatException e) {
        searchProductResults.addAll(Inventory.lookupProduct(searchProduct));
    }
    if (searchProductResults.isEmpty()) {
      mainProductSearchText.clear();
      invalidPopup("No Results", "No results were found matching input.");
      mainProductTableView.setItems(Inventory.getAllProducts());
    } else {
      if (searchProduct.equals("")) {
        mainProductSearchText.clear();
      }
      mainProductTableView.setItems(searchProductResults);
    }
  }

  /**
   * The addProductButtonPushed handles changing the scene when the addProduct button
   * is pushed. A call is made to the AddModifyProductController to initialize
   * the scene with proper labels and flags.
   *
   * @param event Event captured when user clicks on the addProductButtonPushed button.
   */
  @FXML
  private void addProductButtonPushed(ActionEvent event) throws IOException {
    FXMLLoader loader = new FXMLLoader();
    loader.setLocation(getClass().getResource("/View_Controller/AddModifyProduct.fxml"));
    Parent addProductParent = loader.load();
    Scene addProductScene = new Scene(addProductParent);

    AddModifyProductController controller = loader.getController();
    controller.initAddProduct();

    Stage addProductWindow = (Stage) ((Node)event.getSource()).getScene().getWindow();
    addProductWindow.setScene(addProductScene);
    addProductWindow.show();
  }

  /**
   * The modProductButtonPushed handles changing the scene when the modProduct button
   * is pushed. A call is made to the AddModifyProductController to initialize
   * the scene with proper labels and flags.
   *
   * @param event Event captured when user clicks on the modProductButtonPushed button.
   */
  @FXML
  private void modProductButtonPushed(ActionEvent event) throws IOException {
    Product selectedProduct = mainProductTableView.getSelectionModel().getSelectedItem();
    int productIndex = Inventory.getAllProducts().indexOf(selectedProduct);
    if (selectedProduct != null) {
      FXMLLoader loader = new FXMLLoader();
      loader.setLocation(getClass().getResource("/View_Controller/AddModifyProduct.fxml"));
      Parent addProductParent = loader.load();
      Scene addProductScene = new Scene(addProductParent);

      AddModifyProductController controller = loader.getController();
      controller.initModProduct(selectedProduct, productIndex);

      Stage addProductWindow = (Stage) ((Node) event.getSource()).getScene().getWindow();
      addProductWindow.setScene(addProductScene);
      addProductWindow.show();
    } else {
      invalidPopup("No Product Selected.", "Please select a product to modify.");
    }
  }

  @FXML
  private void deleteProductButtonPushed(ActionEvent event) {
    // TODO Implement delete product button pushed method - must confirm part list is empty.
  }


  //===========================================================================
  // Additional Button Handlers
  //===========================================================================

  @FXML
  private void exitButtonPushed(ActionEvent event) {
    if (confirmPopup(event, "Are you sure?", "Please confirm to close the program.")) {
      System.exit(0);
    }
  }
}
